# This script is for rewriting a monitor generated by the rv-monitor script from CCMOP.
# Generated monitors are static, only supporting one "instance" of the monitor.
# This script converts these to classes which can support multiple instances.

import sys
from pathlib import Path


def get_spec_name(input_file):
    parts = input_file.split("_")
    assert len(parts) == 5
    return parts[3]


def get_monitor_class_name(spec_name):
    return f"{spec_name}_Monitor"

# Returns whether the provided input file matches the expected naming format of
# a generated monitor source file.
def is_generated_cc(input_file):
    extension = Path(input_file).suffix
    if extension != ".cc":
        return False
    
    if input_file[:6] != "__RVC_":
        return False
    
    parts = input_file.split("_")
    if len(parts) != 5 or parts[4] != "Monitor.cc":
        return False
    
    return True


# Returns whether the provided input file matches the expected naming format of
# a generated monitor header file.
def is_generated_h(input_file):
    extension = Path(input_file).suffix
    if extension != ".h":
        return False
    
    if input_file[:6] != "__RVC_":
        return False
    
    parts = input_file.split("_")
    if len(parts) != 5 or parts[4] != "Monitor.h":
        return False
    
    return True


# Rewrites a monitor source file.
def rewrite_cc(input_lines, file_out, spec_name):
    file_out.write(f"#include \"{spec_name}_monitor.h\"\n\n")

    for line in input_lines:
        if line[:8] == "#include":
            continue
        
        if line[:27] == "static int __RVC_state = 0;":
            continue
        
        if line.startswith(f"__RVC_{spec_name}_"):
            class_name = get_monitor_class_name(spec_name)
            file_out.write(f"{class_name}::{line}")
        else:
            file_out.write(line)


# Rewrites a monitor header file.
def rewrite_h(input_lines, file_out, spec_name):
    file_out.write("#pragma once\n\n")
    for line in input_lines:
        if line[:6] == "#ifdef" or line[:6] == "#endif":
            continue

        if line[:8] == "#include":
            file_out.write(line)

        if line[:6] == 'extern':
            class_name = get_monitor_class_name(spec_name)
            file_out.write("\n")
            file_out.write(f"class {class_name} {{\n")
            file_out.write("public:\n")
            file_out.write("int __RVC_state = 0;\n\n")
        
        if line[:4] == 'void':
            file_out.write("void\n")
        if line[:6] == "__RVC_":
            file_out.write(line)
        if line[0] == "}":
            file_out.write("};\n")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python monitor_rewriter.py input_file")
        sys.exit(1)

    input_file = sys.argv[1]
    
    is_source = is_generated_cc(input_file) # whether the input file is a source
    is_header = is_generated_h(input_file)  # whether the input file is a header
    
    if not is_source and not is_header:
        print("Error: Input file must be a generated source/header file (e.g. __RVC_XXX_Monitor.cc)")
        sys.exit(1)
    
    spec_name = get_spec_name(input_file)

    try:
        with open(input_file, 'r') as f:
            lines = f.readlines()

        if is_source:
            with open(f"{spec_name}_monitor.cpp", 'w') as f:
                rewrite_cc(lines, f, spec_name)
        
        if is_header:
            with open(f"{spec_name}_monitor.h", 'w') as f:
                rewrite_h(lines, f, spec_name)

    except FileNotFoundError:
        print("Input file not found.")

